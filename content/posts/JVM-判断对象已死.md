---
title: '[JVM]判断对象已死（含GC ROOT）'
author: 土川
tags:
  - JVM
  - GC
categories:
  - Java基础
slug: 2872318404
date: 2018-03-27 02:17:00
---
<!--more-->

看过《深入java虚拟机》，里面对GC的讲解看完有个大概了解。于是自己总结一下。

怎么判断一个对象已死，是GC的第一步。

# 引用计数法
引用计数法就是当对象的引用为0时，才进行GC。事实上这是不可行的。看下面的示例。
> 对象a和b都有一个instance字段，如果执行 
a.instance = b; 
b.instance = a; 
a = null; 
b = null; 

上面的两个对象相互引用着，引用数都为1，但是a和b指的对象都不能再被访问，理论上在内存中是垃圾，但两个对象无法被gc回收。

# 可达性分析算法
我们一般通过可达性分析算法来确认对象的存活。 
* 通过一系列的成为**GC Roots**的引用作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain）
* 当一个对象到GC Roots没有任何引用链相连时，证明此对象不可用
* 在java中可以作为GC Roots的包括下面几种
    * 虚拟机栈中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法中JNI引用的对象
    * 被加载的类
    
> [Java中什么样的对象才能作为gc root，gc roots有哪些呢？](https://www.zhihu.com/question/50381439)

# 再谈引用
java引用在jdk1.2之后进行了扩充，分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）
* 强引用最普遍，GC不会回收被引用的对象
* 软引用用来描述还有用但非必需的对象，要发生OOM时进行清理
* 弱引用用来描述非必需的，只能生存到下次GC收集之前。如果没有强引用引用着这个弱引用对象，就可以在GC回收掉。
* 虚引用也称为幽灵引用和幻影引用。为一个对象设置虚引用的唯一目的：在这个对象被收集器回收时收到一个系统通知

# 生存还是死亡
一个对象进行可达性分析算法后如不可达，也只是进入缓刑。真正宣告一个对象死亡，要经历两次标记：
* 没有和GC Roots相连接，没有则第一次标记
* 被第一次标记过的对象进行筛选，若**未重写finalize()方法**或对象**被执行过一次finalize()**，则**没必要执行finalize()方法**，死刑
* 若对象有必要执行finalize()方法，则对象会被放在一个F-Queue中，并稍后有虚拟机创建的一个**低优先级**的线程去触发方法。
* 对象可以在finalize()方法中自救，比如把自己this赋值给某个变量

> 尽量别使用这个运行代价高昂的方法`finalize()`

# 回收方法区
此处回收两部分内容： 废弃常量和无用的类
* 回收废弃常量和回收java堆中的对象很相似：假如一个字符串“abc”被放进常量池，但系统没有一个string对象是“abc”的，那么内存回收时，“abc”会被清理
* 判断一个类是否是无用的类条件比较苛刻，需满足下面三个：
    * 该类所有实例被回收
    * 加载该类的ClassLoader已经被回收
    * 对应的java.lang.Class 对象没有在任何地方被引用，无法通过反射访问该方法

满足以上三个才“可以”（不是必然）被回收。虚拟机提供了一些参数进行回收
> 在大量使用反射的框架、动态代理的框架、jsp等频繁自定义ClassLoader的场景都需要具备类卸载功能
