---
title: '[JVM]内存模型'
tags:
  - JVM
categories:
  - Java基础
slug: 93872510
date: 2020-03-17 14:28:45
draft: true
---
补个内存模型笔记。
<!--more-->
JVM 内存共分为虚拟机栈、堆、方法区（jdk8是元空间，在jvm之外）、PC寄存器（程序计数器）、本地方法栈五个部分。
![](/images/20200317143112.png)
这是jdk7的实现，方法区其实就是永久代。
![](/images/20200615115524.png)
这是jdk8的实现，永久代废除，将类信息放到本地内存中，也就是放在jvm外。
# 虚拟机栈
线程私有。一个线程一个虚拟机栈

一个栈里有多个帧，栈帧包含局部变量表、操作数栈、动态链接、方法出口等。线程调用方法时会创建栈帧入栈，结束方法时会出栈。

栈深度超过限制会`StackOverflowError`，栈帧申请时内存不足会报`OutOfMemoryError`。

## 局部变量表
用于存放局部变量和方法参数的引用，使用**索引**进行访问。

这个表的组成单位是slot，32位的jvm会使用32位的slot，这也就是为什么**long**/**double**在32jvm不是线程安全的。

> 被虚拟机栈引用的对象，属于GCROOT，不会回收。如果一个方法很长，但是一个大对象不再被使用，可以设置为将大对象的变量赋值为null来帮助gc。（长方法你就该优化一下了）

## 操作数栈
也是存放基本数据类型或引用的，只能进行**出栈/压栈**，使用场景如发起方法调用的时候放参数，算术运算的中间值

## 动态链接
一个引用，指向方法区的方法，由于java多态特性，编译后大多数不能确定哪个方法的调用，只能在运行时才能将符号引用转换为直接引用。

## 方法返回值
如果方法是正常退出（没有异常）且有返回值，调用方需要从这里取到返回值，并在栈帧的操作数栈进行压栈。

# PC寄存器（程序计数器）
线程私有。一个线程一个PC寄存器，也叫程序计数器。

PC寄存器存放了线程当前执行的指令的地址，用于上下文切换后恢复线程上下文。

如果当前执行的是**native**方法，那么PC寄存器为空。
# 本地方法栈
线程私有。一个线程一个本地方法栈。

类似于**虚拟机栈**，只不过表示的是**native**方法。

栈深度超过限制会`StackOverflowError`，栈帧申请时内存不足会报`OutOfMemoryError`。

# 堆
线程共享。GC区域。

# 方法区(元空间)
线程共享。主要用于存储类的信息、常量池、静态变量、及时编译器编译后的代码等数据。方法区逻辑上属于堆内存。这就给gc带来了负担，因为这些基本都是不变的对象。

jdk8将这部分挪到堆外内存，称为元空间（Metaspace）

## 方法区，元空间与永久代
**方法区**是jvm规范，Hotspot以前用**永久代**实现，放在了堆内存里。jdk8完全废除了**永久代**，将这些数据放到了**本地内存**。

主要原因是:
1. 常量存在永久代中，容易出现性能问题和内存溢出。
1. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。比如jsp生成动态类，这是比较难预测的。
1. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低，毕竟这些东西是一直不变的。
