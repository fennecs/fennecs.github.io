---
title: '[JVM]垃圾回收算法简介'
author: 土川
tags:
  - JVM
  - GC
categories:
  - Java基础
slug: 2456754784
date: 2018-03-27 11:08:00
draft: true
---
> 识别出了垃圾以后怎么清除呢。

<!--more-->
下面的几种垃圾回收算法在不同的空间都有不同应用。
# 标记-清除算法（Mark-Sweep）
标记出所有要回收的对象，然后统一回收。  
不足：
* 效率低下 
* 空间碎片太多（导致分配大对象没有连续空间，不得不触发另一次垃圾收集动作）

# 复制算法
基于前面的算法，把内存按容量分为两部分，第一次使用其中一部分，在gc完成后将存活对象复制到另一部分内存，清除第一部分的内存。

但是按照把内存划分为两半，可用内存就缩小为一半，代价真他妈高

于是现代的商业虚拟机都是采用这种方式，但不是1：1分配内存而是分为一块较大的Eden和两块较小的Survivor(一般来说是8：1：1)。  
当回收时，将Eden和Survivor中的存活对象一次性地复制到另外一块Survivor空间上，清理掉原来的Eden和Survivor中的空间

## 为什么要有两块Survivor
假设有survivor1和survivor2，那么eden和survivor1进行minor gc后一般survivor1会有内存碎片，这时候把存活对象放进空的survivor2，清空survivor1，就能解决内存碎片化问题。
## 为什么不设多点survivor
两块够了。。

> 如果空间不足，则使用分配担保机制来申请内存

# 标记-整理算法
复制收集算法在对象存活率较高时就要进行较多的复制操作，效率变低。
标记-整理算法在标记之后，将存活对象都往一端移动，最后直接清理端边界以外的内存。

# 分代收集算法
将内存分为“新生代”“老年代”，新生代使用复制算法。老年代是用标记-清除算法、标记-整理算法。