---
title: "M1"
date: 2024-01-28T18:05:39+08:00
draft: true
slug: c7b76353
---

## M1
参数解析用`getopt_long`.

算法实现先构造一棵树, 然后DFS遍历, 递归输出节点. 递归的过程需要维护一个`prefix`字符串, 这样就有统一的缩进啦.

## M2
> 不妨把矩形旋转 45 度一一你会发现，我们可以在`2n-1`“步”之内计算完所有节点上的数值，而每一步里的节点都是可以并行计算的：

这个`n`是指两个字符串的长度, 如果两个字符长度相等, 那么就有`2n-1`条对角线, 当然不等的情况下, 应该是`M+N-1`条. 

算法的核心就是:
```c
for (int round = 0; round < M + N - 1; round++) {
  // 1. 计算出本轮能够计算的单元格
  // 2. 将任务分配给线程执行
  // 3. 等待线程执行完毕
}
```
比如有一个case: `N=4`的字符串A, `M=5`的字符串B, 线程数`T=3`.

当`round=2`时(从0开始计数的话, 其实是第3轮), 对角上有`(0, 2)`, `(1, 1)`, `(2, 0)`三个单元格.

把这三个计算单元格均摊到`T=3`个线程中运行, 然后主线程等待同步, 就可以进行下一轮计算.

### v1.0
我们定义一个结构体:
```c
/**
 * @param lx: left x(闭)
 * @param rx: right x(开)
 * @param round: 
 */
struct Task {
  int lx, rx, round;
}
```
* 对于对角线上的点, `round = x + y`, 所以只要维护`round`和`[lx, rx)`即可, 就能实现`1. 计算出本轮能够计算的单元格`
* 维护一个`sem_t sem[]`, 实现`2. 将任务分配给线程执行`的生产和消费
* 维护一个`sem_t done`, 实现`3. 等待线程执行完毕`
