---
title: "PA2 RTFSC"
date: 2023-03-25T00:41:31+08:00
draft: true
slug: 854ef98d
---

# 立即数背后的故事
如果把内存地址按栈摆放就是这样，解释指针时是从低地址往高地址解释的，所以小端在数值转换比较方便，比如32位数`0x1234`要解释为8位数字，只需要解释指针的时侯取第一个字节即可。

```
    +----+
x+3 | 00 |
    +----+
x+2 | 00 |
    +----+
x+1 | 12 |
    +----+
x   | 34 |
    +----+
```

* 运行在**Motorola 68k**架构的处理器时，**读取立即数**应该按数据宽度读取n个字节，然后将字节数组逆序，按大端存储
* 模拟**Motorola 68k**架构时，**读取立即数**应该按数据宽度读取n个字节，然后将字节数组逆序，按小端存储


# 立即数背后的故事(2)
~~指令长度只有32位，盲猜是用分页的思想，把低位和高位拆开，一部分放寄存器里，利用寄存器做索引。（待求证~~
高位低位拆开，然后用一个加法相加

# RTFSC理解指令执行的过程

基本就是下图的流程不停地重复，

![](/images/20230328004004.png)

# 为什么执行了未实现指令会出现上述报错信息
流程图`switch(opcode)`这一步，如果没有实现对应指令，会走到`default`分支，执行`exec_inv`

# 运行第一个客户程序
![](/images/20230409123932.png)

# 其他

# 数的扩展
由于NEMU的数据宽度都是用`word_t`/`sword_t`，带符号数应该用`sword_t`表示。riscv32的`sword_t`是4个字节，如果操作数不是4个字节，需要做符号扩展，用到的rtl函数是`rtl_sext`，可以利用位域来实现，用到的宏是

```c
#define SEXT(x, len) ({ struct { int64_t n : len; } __x = { .n = x }; (int64_t)__x.n; })
```
其中len是最高位的位置（从1开始）

# `HIT BAD TRAP`
各种编码的小马虎，都可能会导向`HIT BAD TRAP`，所以手册指令描述应该看仔细，可以少走弯路。

~~另外就是对指令的不熟悉也会踩坑。但我们锻炼的能力就是如何在不熟悉的前提下编程，~~

~~当遇到`HIT BAD TRAP`，去读懂全部指令逻辑的话成本太高（又不是搞逆向的），可以查看**nemu-log.txt**(build目录下)，大约定位到`check`失败的条件，顺着条件回溯，找到`eflags`不符合预期的pc，从而定位到哪条指令实现有问题~~

~~具体怎么做呢，基础设施的实现就可以帮到你了～~~

看来PA要完整地看。。。第四节的**基础设施**有DiffTest。。。

# 解析指令
写了个`riscv`命令用于解析riscv指令，效果如下：

    (nemu) riscv f61ff0ef
    
    1111011 ????? ????? 111 ????? 1101111

# mulh
同有符号加法一样，有符号乘法也是把负数用补码表示，免去了单独计算符号位的问题，这也是有符号运算和无符号计算的区别，无符号计算开箱即用，有符号数需要先对负数转补码（正数的补码即原码，无需转换）